Directory structure:
└── src/
    ├── sceneManager.js
    ├── solarSystem.js
    └── model/
        ├── Body.js
        ├── Marker.js
        └── Orbit.js

================================================
File: sceneManager.js
================================================
import * as THREE from "three";
import { InteractionManager } from 'three.interactive';
import { OrbitControls } from 'three/addons';
import TWEEN, {Tween} from '@tweenjs/tween.js';

// SceneManager.js
class SceneManager {
  constructor() {
    if (SceneManager.instance) {
      return SceneManager.instance;
    }

    const aspectRatio = window.innerWidth / window.innerHeight;

    const default_near = 5;
    const default_far = 7000;

    this.object = null;
    this.scene = new THREE.Scene();
    this.camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.0001, 12000);
    this.camera.position.set(0, 6500, 6500);
    this.renderer = new THREE.WebGLRenderer();
    this.renderer.setSize(window.innerWidth, window.innerHeight);

    this.interactionManager = new InteractionManager(
      this.renderer,
      this.camera,
      this.renderer.domElement
    );

    document.body.appendChild(this.renderer.domElement);
    this.controls = new OrbitControls(this.camera, this.renderer.domElement);
    this.controls.minDistance = default_near;
    this.controls.maxDistance = default_far;
    this.controls.enableDamping = true;
    this.target = null;

    window.addEventListener('resize', function(e) {
      new SceneManager().#onWindowResize()
    }, false);

    this.#onWindowResize()
    SceneManager.instance = this;
    return this;
  }

  #onWindowResize() {
    this.camera.aspect = window.innerWidth / window.innerHeight;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(window.innerWidth, window.innerHeight);
  }

  render() {
     if (this.target) {
       this.camera.position.sub(this.controls.target)
       this.controls.target.copy(this.target.position);
       this.camera.position.add(this.target.position);

       this.controls.update()
     }

    this.renderer.render(this.scene, this.camera)
  }

  /**
   * Sets control target to group
   * @param {THREE.Group} group - The group to target.
   */
  setTarget(group) {
    this.target = group;
    this.controls.target.copy(this.target.position)
  }
}

// Export the singleton instance
export default new SceneManager();




================================================
File: solarSystem.js
================================================
import SceneManager from "./sceneManager.js";
import Orbit from './model/Orbit.js';
import Body from './model/Body.js';
import * as THREE from 'three';
import Stats from 'stats-gl';


const stats = new Stats({horizontal: false, trackGPU: true});
stats.init( SceneManager.renderer );
document.body.appendChild(stats.dom);

const sun = new Body(
  "Sun",
  1,
  new THREE.MeshBasicMaterial({color: 0xffff00}),
  true,
  new THREE.PointLight(0xffffff, 10000000),
);

const planets = [
    { name: 'Mercury', color: 0x8B7B6F, radius: sun.radius * 0.00350366313, a: 0.39, e: 0.2056, inclination: 7 },
    { name: 'Venus', color: 0xC9AEBE, radius: sun.radius * 0.00869074857, a: 0.72, e: 0.0068, inclination: 3.4 },
    { name: 'Earth', color: 0x007FFF, radius: sun.radius * 0.00915921329, a: 1, e: 0.0167, inclination: 0 },
    { name: 'Mars', color: 0xFF8C00, radius: sun.radius * 0.00486745707, a: 1.52, e: 0.0934, inclination: 1.85 },
    { name: 'Jupiter', color: 0xD2691E, radius: sun.radius * 0.10039681989, a: 5.2, e: 0.0484, inclination: 1.3 },
    { name: 'Saturn', color: 0xFFD700, radius: sun.radius * 0.08362569044, a: 9.58, e: 0.0542, inclination: 2.49 },
    { name: 'Uranus', color: 0xADD8E6, radius: sun.radius * 0.03642099424, a: 19.18, e: 0.0472, inclination: 0.77 },
    { name: 'Neptune', color: 0x1E90FF, radius: sun.radius * 0.03535880191, a: 30.07, e: 0.0086, inclination: 1.77 },
    { name: 'Pluto', color: 0xBEBEBE, radius: sun.radius * 0.00170648732, a: 39.48, e: 0.2488, inclination: 17.14 },
    // { name: 'X', color: 0xe012da, radius: sun.radius * 0.03642099424, a: 50.48, e: 0.5, inclination: 90 }
];

let orbits = [];
planets.forEach(planet => {
    orbits.push(new Orbit(
        new Body(
          planet.name,
          planet.radius,
          new THREE.MeshLambertMaterial(
            {color: planet.color}
          ),
          true,
        ),
        planet.a,
        planet.e,
        planet.inclination
    ));
});


// Animation loop
function animate(timestamp) {
    orbits.forEach(orbit => {
        orbit.update(timestamp / 500000);
    })

    SceneManager.render()
    stats.update()
}

console.log(SceneManager.camera)
SceneManager.setTarget(sun.group);
SceneManager.renderer.setAnimationLoop(animate);



================================================
File: model/Body.js
================================================
import * as THREE from 'three';
import Marker from './Marker.js';
import SceneManager from '../sceneManager.js';


class Body {
    /**
     * Creates a new celestial body with specified properties.
     * @param {string} name - The body name.
     * @param {number} radius - The radius of the sphere geometry.
     * @param {THREE.Material} material - The material used by the body.
     * @param {THREE.PointLight} emittedLight - The light emitted from the body.
     * @param {boolean} [marker=true] - Whether to add a marker to the body.
     */
    constructor(
      name,
      radius,
      material,
      marker = true,
      emittedLight = null,
    ) {
        this.name = name;
        this.radius = radius;
        this.emittedLight = emittedLight;
        this.material = material;
        this.isTarget = false;

        // Create basic materials and geometries
        this.geometry = this.createGeometry();

        // Create mesh and group structure
        this.mesh = this.createMesh();
        this.group = this.createGroup();

        // Add marker to body
        if (marker) {
            this.marker = new Marker(this);
        }

        // Set emitted light to body position
        if (this.emittedLight) {
            this.emittedLight.position.copy(this.mesh.position)
            this.group.add(this.emittedLight);
        }

        console.log(this.marker)
        SceneManager.scene.add(this.group);
    }

    /**
     * Creates the geometry for the celestial body.
     * @returns {THREE.SphereGeometry} The created geometry.
     */
    createGeometry() {
        return new THREE.SphereGeometry(this.radius, 32, 32);
    }

    /**
     * Creates the mesh using the material and geometry.
     * @returns {THREE.Mesh} The created mesh.
     */
    createMesh() {
        return new THREE.Mesh(this.geometry, this.material);
    }

    /**
     * Creates the group structure for the body.
     * @returns {THREE.Group} The created group.
     */
    createGroup() {
        const bodyContainer = new THREE.Group();
        const group = new THREE.Group();
        group.add(this.mesh);
        bodyContainer.add(group);

        return bodyContainer;
    }

    target() {
        if (SceneManager.target) {}
    }
}

export default Body;



================================================
File: model/Marker.js
================================================
import * as THREE from 'three';
import { SVGLoader } from 'three/examples/jsm/loaders/SVGLoader';
import markerSVG from '../../assets/marker.svg'
import SceneManager from '../sceneManager';


const loader = new SVGLoader();
const svgContent = await loader.loadAsync(markerSVG);
const svgObject = new THREE.Group();
let renderOrder = 0

svgContent.paths.forEach(path => {
    const material = new THREE.MeshBasicMaterial({
        color: path.color,
        side: THREE.DoubleSide,
        depthWrite: false,
    });

    const shapes = SVGLoader.createShapes(path);
    shapes.forEach(shape => {
        const geometry = new THREE.ShapeGeometry(shape);
        const mesh = new THREE.Mesh(geometry, material);
        mesh.name = `${path.userData.node.nodeName}#${path.userData.node.id}`;
        mesh.renderOrder = renderOrder++;
        svgObject.add(mesh);
    });
});

svgObject.name = svgContent.xml.id;


class Marker {
    constructor(body, scale = .002) {
        this.body = body;
        this.scale = scale;
        this.orbitRadius = 2 * this.body.radius; // Default orbit radius, adjust as needed
        this.group = this.#build();
    }

    #build() {
        // Clone the SVG group.
        const markerContainer = new THREE.Group();
        this.marker = svgObject.clone()

        this.marker.addEventListener("click", (event) => {
            event.stopPropagation();
            console.log(`${this.body.name} marker was clicked`);

            SceneManager.setTarget(this.body.group)
            SceneManager.controls.minDistance = this.body.radius * 3
            SceneManager.controls.maxDistance = this.body.radius * 100
        });

        SceneManager.interactionManager.add(this.marker);

        // Marker Shape Color.
        const shapeMesh = this.marker.children.find(mesh => mesh.name === "path#Shape");
        shapeMesh.material = new THREE.MeshBasicMaterial({
            color: this.body.material.color,
        });

        // Invert Y Axis to avoid upside down SVG.
        this.marker.scale.set(this.scale, -this.scale);

        // Add marker to container group.
        markerContainer.add(this.marker);
        this.marker.position.copy(this.body.group.position);
        const boundingBox = new THREE.Box3().setFromObject(this.marker);
        this.size = boundingBox.getSize(new THREE.Vector2());
        this.marker.position.setX(this.size.x / -2);

        // Add marker container to body group.
        this.body.group.add(markerContainer);

        return markerContainer;
    }

    #scale() {
        // Calculate distance from the camera to the marker using frustum
        const vector = new THREE.Vector4();
        vector.copy(this.body.group.position).applyMatrix4(SceneManager.camera.matrixWorldInverse);
        const distance = Math.abs(vector.z); // Note: This assumes a perspective camera

        // Scale the marker based on its distance from the camera
        const scaleFactor = (distance + 1e-6) / 5; // Avoid division by zero

        this.group.scale.set(scaleFactor, scaleFactor, scaleFactor);
        this.marker.position.setY((this.body.radius / scaleFactor) + this.size.y * 1.2);
    }

    #orientate() {
        this.group.quaternion.copy(SceneManager.camera.quaternion);
    }

    update() {
        if (!this.group) return;

        // Keep camera orientation
        this.#orientate();

        // Scale based on distance from camera
        this.#scale();
    }
}

export default Marker;



================================================
File: model/Orbit.js
================================================
import * as THREE from 'three';
import SceneManager from '../sceneManager';

const auScale = 83.238648145;
const PI_OVER_180 = Math.PI / 180;
const GM = 4 * Math.PI ** 2 * auScale ** 3;
//const orbitMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });


class Orbit {
    /**
     * Represents an orbital path for a celestial body.
     */
    constructor(body, semiMajorAxis, eccentricity, inclination = 0) {
        const orbitMaterial = new THREE.LineBasicMaterial({ color: body.material.color });
        this.body = body;
        this.semiMajorAxis = semiMajorAxis * auScale;
        this.eccentricity = eccentricity;
        this.inclinationRadians = inclination * PI_OVER_180;

        // Orbital mechanics properties
        this.n = Math.sqrt(GM / Math.pow(semiMajorAxis, 3)) / 100;
        this.orbitalPeriod = 2 * Math.PI / this.n;

        // Precompute rotation matrix for inclination
        this.rotationMatrix = new THREE.Matrix4().makeRotationX(this.inclinationRadians);

        // Create visual orbit path
        SceneManager.scene.add(new THREE.LineLoop(this.#createOrbitPath(), orbitMaterial));
    }

    /**
     * Creates the geometric representation of the orbital path.
     * @returns {THREE.BufferGeometry} The geometry representing the orbit path.
     */
    #createOrbitPath() {
        const points = [];
        const steps = this.#circumference() / 2;
        console.log(steps)

        for (let i = 0; i <= steps; i++) {
            const t = i / steps * this.orbitalPeriod;
            points.push(this.#calculatePosition(t));
        }

        points.push(points[0].clone());
        
        return new THREE.BufferGeometry().setFromPoints(points);
    }

     #circumference() {
         const a = this.semiMajorAxis;
         const e = this.eccentricity;
         const b = a * Math.sqrt(1 - e ** 2);
         
         return Math.PI * (3 * (a + b) - Math.sqrt((3 * a + b) * (a + 3 * b)));
     }


    /**
     * Calculates the position of the body at a given time.
     * @param {number} t - Time parameter in seconds.
     * @returns {THREE.Vector3} The calculated position.
     */
    #calculatePosition(t) {
        const meanAnomaly = this.n * t;
        let eccentricAnomaly = this.#solveKeplerEquation(meanAnomaly);

        // Convert to true anomaly
        const tanNuOver2 = Math.sqrt((1 + this.eccentricity) / (1 - this.eccentricity)) * Math.tan(eccentricAnomaly / 2);
        const trueAnomaly = 2 * Math.atan(tanNuOver2);

        // Calculate radial distance
        const r = this.semiMajorAxis * (1 - this.eccentricity * Math.cos(eccentricAnomaly));

        // Initial position in orbital plane
        const x = r * Math.cos(trueAnomaly);
        const z = r * Math.sin(trueAnomaly);

        return new THREE.Vector3(x, 0, z).applyMatrix4(this.rotationMatrix);
    }

    /**
     * Solves Kepler's equation using iterative method.
     * @param {number} meanAnomaly - Mean anomaly in radians.
     * @returns {number} Eccentric anomaly in radians.
     */
    #solveKeplerEquation(meanAnomaly) {
        let eccentricAnomaly = meanAnomaly;
        
        for (let i = 0; i < 10; i++) {
            eccentricAnomaly = meanAnomaly + this.eccentricity * Math.sin(eccentricAnomaly);
        }
        
        return eccentricAnomaly;
    }

    /**
     * Updates the body's position based on time.
     * @param {number} timestamp - Current timestamp in milliseconds.
     */
    update(timestamp) {
        this.body.group.position.copy(this.#calculatePosition(timestamp));
        this.body.marker?.update();
    }
}

export default Orbit;


